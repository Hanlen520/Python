#!/usr/bin/evn python
# -*- coding:utf-8 -*-
# by author: crisimple

from types import MethodType


# ======================================================================================================================
# 10.1.使用__slots__
class Student(object):
    pass


# 给实例绑定一个属性
s = Student()
s.name = 'Crisimple'
print(s.name)


# 给实例绑定一个方法
def set_age(self, age):
    self.age = age


# 给实例绑定一个方法
s.set_age = MethodType(set_age, s)
# 调用实例方法；但是，给一个实例绑定的方法，对另一个实例是不起作用的：
s.set_age(25)
print(s.age)


# 但是，给一个实例绑定的方法，对另一个实例是不起作用的
# 为了给所有实例都绑定方法，可以给class绑定方法，即我们可以在程序运行的时候给类加上方法也可以在类中定义方法
def set_score(self, score):
    self.score = score


Student.set_score = set_score
s.set_score(100)
print(s.score)


# 要限制实例的属性--__slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称,
# 没有被放到__slots__中的属性，就不能绑定这个属性
# 注意：__slots__定义的属性仅对当前类实例起作用，
# 对继承的子类是不起作用的（除非子类中也用__slots__定义了些属性，
# 这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。）


# ======================================================================================================================
# 10.2.使用@property
# 在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改
# Python内置的@property装饰器就是负责把一个方法变成属性调用的
# @property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：
class Student(object):

    @property
    def score(self):
        return self.score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value > 0 or value < 100:
            raise ValueError('score must between 0 ~ 100')
        self.score = value
# ======================================================================================================================
# 10.3.多重继承
# 继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能。
# 通过多重继承，一个子类就可以同时获得多个父类的所有功能。
# MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能


# ======================================================================================================================
# 10.4.定制类
# 形如__xxx__的变量或者函数名就要注意，这些在Python中是有特殊用途的
#   1. __str__ 和 __repr__
#   2. __iter__（如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。）
#   3. __getitem__
#   4. __getattr__ （正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。当调用不存在的属性时，比如score，Python解释器会试图调用__getattr__(self, 'score')来尝试获得属性）
#   5. __call__ [任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用。通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。]


# ======================================================================================================================
# 10.5.使用枚举类
# 定义常量时，一个办法是用大写变量通过整数来定义
# 既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量
from enum import Enum
Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))


# ======================================================================================================================
# 10.6.使用元类
# 动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的
# type()函数既可以返回一个对象的类型，又可以创建出新的类型
# 要创建一个class对象，type()函数依次传入3个参数：
#       class的名称；
#       继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；
#       class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。

# metaclass（直译为元类）：除了使用type()动态创建类以外，要控制类的创建行为，还可以使用metaclass。


