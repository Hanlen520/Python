#!/usr/bin/evn python
# -*- coding:utf-8 -*-
# by author: crisimple

from types import MethodType


# ======================================================================================================================
# 10.1.使用__slots__
class Student(object):
    pass


# 给实例绑定一个属性
s = Student()
s.name = 'Crisimple'
print(s.name)


# 给实例绑定一个方法
def set_age(self, age):
    self.age = age


# 给实例绑定一个方法
s.set_age = MethodType(set_age, s)
# 调用实例方法；但是，给一个实例绑定的方法，对另一个实例是不起作用的：
s.set_age(25)
print(s.age)


# 但是，给一个实例绑定的方法，对另一个实例是不起作用的
# 为了给所有实例都绑定方法，可以给class绑定方法
def set_score(self, score):
    self.score = score


Student.set_score = set_score
s.set_score(100)
print(s.score)


# 要限制实例的属性--__slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称,
# 没有被放到__slots__中的属性，就不能绑定这个属性


# ======================================================================================================================
# 10.2.使用@property
# 在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改
# Python内置的@property装饰器就是负责把一个方法变成属性调用的
# @property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值


# ======================================================================================================================
# 10.3.多重继承
# 继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能。
# 通过多重继承，一个子类就可以同时获得多个父类的所有功能。


# ======================================================================================================================
# 10.4.定制类
# 形如__xxx__的变量或者函数名就要注意，这些在Python中是有特殊用途的


# ======================================================================================================================
# 10.5.使用枚举类
# 定义常量时，一个办法是用大写变量通过整数来定义
# 既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量


# ======================================================================================================================
# 10.6.使用元类
# type()
# 动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的


